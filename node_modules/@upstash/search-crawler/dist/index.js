#!/usr/bin/env node

// src/index.ts
import { Command } from "commander";
import { Search } from "@upstash/search";
import { intro, outro, text, confirm, spinner, isCancel } from "@clack/prompts";
import chalk3 from "chalk";

// src/crawler/linkFinder.ts
import axios from "axios";
import * as cheerio from "cheerio";
async function getInternalDocLinks(baseUrl) {
  const response = await axios.get(baseUrl);
  const $ = cheerio.load(response.data);
  const links = /* @__PURE__ */ new Set();
  let main2 = $("main");
  if (main2.length === 0) {
    main2 = $('div[role="main"], .body[role="main"]');
  }
  main2.find("a[href]").each((_, element) => {
    const href = $(element).attr("href");
    if (!href) return;
    let url;
    try {
      url = new URL(href, baseUrl).toString();
    } catch {
      return;
    }
    if (url.startsWith(baseUrl)) {
      links.add(url);
    }
  });
  return Array.from(links);
}
async function getAllDocLinks(baseUrl) {
  try {
    const sitemapUrl = baseUrl.endsWith("/") ? new URL("sitemap.xml", baseUrl).toString() : new URL(`${baseUrl}/sitemap.xml`).toString();
    const response = await axios.get(sitemapUrl, { timeout: 5e3 });
    if (response.status === 200 && response.data) {
      const urls = [];
      const $ = cheerio.load(response.data, { xmlMode: true });
      $("url > loc").each((_, el) => {
        urls.push($(el).text().trim());
      });
      if (urls.length > 0) return urls;
    }
  } catch (e) {
  }
  return getInternalDocLinks(baseUrl);
}

// src/crawler/extractor.ts
import axios2 from "axios";
import * as cheerio2 from "cheerio";

// src/utils/cleanText.ts
function cleanTextContent(text2) {
  return text2.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "").replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").replace(/[{}:;]/g, " ").replace(/\b(var|function|const|let|return|if|else|for|while)\b/g, "").replace(/[a-zA-Z-]+-[a-zA-Z0-9-]*/g, "").replace(/\b[a-zA-Z-]+\b(?=\s*\{)/g, "").replace(/\s+/g, " ").trim();
}

// src/crawler/extractor.ts
import chalk from "chalk";
async function crawlDocumentation(url) {
  try {
    const response = await axios2.get(url);
    if (response.status !== 200) {
      throw new Error(chalk.red(`Failed to crawl: ${url} - Status: ${response.status}`));
    }
    const $ = cheerio2.load(response.data);
    const results = [];
    $("script, style, nav, footer, .nav, .sidebar, .menu, .footer, .sidebar-group, a").remove();
    let main2 = $("main");
    if (main2.length === 0) {
      main2 = $('div[role="main"], .body[role="main"]');
    }
    const baseTitle = main2.find("h1, h2").first().text().trim();
    const headings = main2.find("h1, h2, h3");
    if (headings.length > 0) {
      headings.each((index2, element) => {
        const $heading = $(element);
        const headingText = $heading.text().trim();
        const headingId = $heading.attr("id");
        let content = "";
        const headerParent = $heading.parents("header").first();
        if (headerParent.length > 0) {
          let contentContainer = null;
          const contentSelectors = [".mdx-content", ".content", ".main-content", '[class*="content"]'];
          for (const selector of contentSelectors) {
            contentContainer = headerParent.nextAll(selector).first();
            if (contentContainer.length > 0) break;
          }
          if (!contentContainer || contentContainer.length === 0) {
            headerParent.nextAll().each((i, elem) => {
              const $elem = $(elem);
              const textContent = $elem.text().trim();
              if (textContent.length > 50) {
                contentContainer = $elem;
                return false;
              }
            });
          }
          if (contentContainer && contentContainer.length > 0) {
            let contentText = "";
            contentContainer.contents().each((i, elem) => {
              const $elem = $(elem);
              if ($elem.is("h1, h2, h3")) {
                return false;
              }
              contentText += $elem.text() + " ";
            });
            content = contentText.trim();
          }
        } else {
          content = $heading.nextUntil("h1, h2, h3").text().trim();
        }
        const cleanContent = cleanTextContent(content);
        if (cleanContent) {
          let sectionUrl, sectionPath;
          if (headerParent && headerParent.length > 0) {
            sectionUrl = url;
            sectionPath = url.replace(new URL(url).origin, "");
          } else {
            sectionUrl = headingId ? `${url}#${headingId}` : url;
            sectionPath = headingId ? `${url.replace(new URL(url).origin, "")}#${headingId}` : url.replace(new URL(url).origin, "");
          }
          results.push({
            url: sectionUrl,
            title: headingText || baseTitle,
            content: cleanContent,
            path: sectionPath
          });
        }
      });
    }
    return results;
  } catch (error) {
    throw new Error(chalk.red(`Error crawling: ${url} - ${error}`));
  }
}

// src/crawler/indexer.ts
import chalk2 from "chalk";
import crypto from "crypto";
async function upsertToUpstash(data, index2) {
  try {
    const batchSize = 100;
    let totalUpserted = 0;
    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      const upstashBatch = batch.map((item, idx) => {
        const id = crypto.createHash("md5").update(item.url + item.title + item.content).digest("hex");
        const content = {
          title: item.title,
          fullContent: item.content.substring(0, 1200)
        };
        const metadata = {
          url: item.url,
          path: item.path,
          contentLength: item.content.length,
          crawledAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        return { id, content, metadata };
      });
      await index2.upsert(upstashBatch);
      totalUpserted += batch.length;
    }
  } catch (error) {
    throw new Error(chalk2.red("Error upserting to Upstash:") + " " + chalk2.red(error));
  }
}
async function compareWithExistingData(currentData, index2, s) {
  try {
    let cursor = 0;
    const limit = 100;
    let allDocIds = [];
    while (true) {
      const { nextCursor, documents } = await index2.range({
        cursor,
        limit,
        prefix: ""
      });
      allDocIds = allDocIds.concat(documents.map((doc) => doc.id));
      if (!nextCursor) break;
      cursor = nextCursor;
    }
    const currentLookupKeys = new Set(
      currentData.map(
        (item) => crypto.createHash("md5").update(item.url + item.title + item.content).digest("hex")
      )
    );
    const obsoleteIds = [];
    for (const docId of allDocIds) {
      if (!currentLookupKeys.has(docId)) {
        obsoleteIds.push(docId);
      }
    }
    if (obsoleteIds.length > 0) {
      s.message(chalk2.red(`Removing ${obsoleteIds.length} obsolete items`));
      await batchDelete(obsoleteIds, index2, s);
    } else {
      s.message(chalk2.green("No obsolete items found."));
    }
    const allDocIdSet = new Set(allDocIds);
    const newOrChangedItems = currentData.filter((item) => {
      const hash = crypto.createHash("md5").update(item.url + item.title + item.content).digest("hex");
      return !allDocIdSet.has(hash);
    });
    return newOrChangedItems;
  } catch (error) {
    throw new Error(chalk2.red("Error removing obsolete entries: ") + error.message);
  }
}
async function batchDelete(ids, index2, s) {
  const batchSize = 100;
  for (let i = 0; i < ids.length; i += batchSize) {
    const batch = ids.slice(i, i + batchSize);
    await index2.delete({ ids: batch });
    s.message(chalk2.red(`Deleted batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(ids.length / batchSize)}`));
  }
}

// src/index.ts
var upstashClient;
var index;
async function crawlAndIndex(options) {
  try {
    const { upstashUrl, upstashToken, indexName = "default", docUrl } = options;
    upstashClient = new Search({
      url: upstashUrl,
      token: upstashToken
    });
    index = upstashClient.index(indexName);
    const s = spinner();
    s.start(chalk3.cyan("Crawling documentation"));
    const links = await getAllDocLinks(docUrl);
    if (!links.includes(docUrl)) links.unshift(docUrl);
    s.message(chalk3.cyan(`Found ${links.length} pages to crawl. Starting`));
    const results = [];
    for (let i = 0; i < links.length; i++) {
      const link = links[i];
      s.message(chalk3.cyan(`Crawling ${i + 1}/${links.length}: ${link}`));
      const contents = await crawlDocumentation(link);
      results.push(...contents);
    }
    s.message(chalk3.cyan(`Crawled ${results.length} content sections. Fetching existing data`));
    const newContents = await compareWithExistingData(results, index, s);
    if (newContents.length > 0) {
      s.message(chalk3.cyan(`Found ${newContents.length} new records. Upserting to Upstash`));
      await upsertToUpstash(newContents, index);
      s.stop(chalk3.green(`\u2705 Successfully crawled and upserted ${newContents.length} new records!`));
      return {
        success: true,
        newRecordsCount: newContents.length,
        totalRecordsCount: results.length
      };
    } else {
      return {
        success: true,
        newRecordsCount: 0,
        totalRecordsCount: results.length
      };
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      newRecordsCount: 0,
      totalRecordsCount: 0,
      error: errorMessage
    };
  }
}
async function main() {
  const program = new Command();
  program.option("--upstash-url <url>", "Upstash URL").option("--upstash-token <token>", "Upstash Token").option("--index-name <name>", "Index Name").option("--doc-url <url>", "Documentation URL").parse(process.argv);
  const options = program.opts();
  intro(chalk3.cyan("Create a search index for your documentation"));
  try {
    const upstashUrl = options?.upstashUrl ?? await text({
      message: "Enter your Upstash Search URL:",
      placeholder: "https://***.upstash.io",
      validate: (value) => {
        if (!value) return "URL is required";
        if (!value.startsWith("https://")) return "URL must start with https://";
      }
    });
    if (isCancel(upstashUrl)) {
      outro("Crawling cancelled.");
      return;
    }
    const upstashToken = options?.upstashToken ?? await text({
      message: "Enter your Upstash Search token:",
      placeholder: "AB4FMH...",
      validate: (value) => {
        if (!value) return "Token is required";
      }
    });
    if (isCancel(upstashToken)) {
      outro("Crawling cancelled.");
      return;
    }
    let indexName = options?.indexName ?? "default";
    if (!options?.indexName) {
      const useDefaultIndex = await confirm({
        message: `Use the default index name (${chalk3.green("default")})?`
      });
      if (!useDefaultIndex) {
        const customIndex = await text({
          message: "Enter your custom index name:",
          placeholder: "my-index",
          validate: (value) => {
            if (!value) return "Index name is required";
          }
        });
        indexName = customIndex;
      }
    }
    if (isCancel(indexName)) {
      outro("Crawling cancelled.");
      return;
    }
    upstashClient = new Search({
      url: upstashUrl,
      token: upstashToken
    });
    index = upstashClient.index(indexName);
    const docUrl = options?.docUrl ?? await text({
      message: "Enter the documentation URL to crawl:",
      placeholder: "https://upstash.com/docs",
      validate: (value) => {
        if (!value) return "URL is required";
        if (!value.startsWith("http")) return "URL must start with http:// or https://";
      }
    });
    if (isCancel(docUrl)) {
      outro("Crawling cancelled.");
      return;
    }
    if (!(options?.docUrl && options?.indexName && options?.upstashUrl && options?.upstashToken)) {
      const shouldProceed = await confirm({
        message: `Ready to crawl ${chalk3.cyan(String(docUrl))} and upsert to Upstash Search index ${chalk3.green(indexName)}?`
      });
      if (isCancel(shouldProceed)) {
        outro("Crawling cancelled.");
        return;
      }
    }
    const s = spinner();
    s.start(chalk3.cyan("Crawling documentation"));
    const links = await getAllDocLinks(docUrl);
    if (!links.includes(docUrl)) links.unshift(docUrl);
    s.message(chalk3.cyan(`Found ${links.length} pages to crawl. Starting`));
    const results = [];
    for (let i = 0; i < links.length; i++) {
      const link = links[i];
      s.message(chalk3.cyan(`Crawling ${i + 1}/${links.length}: ${link}`));
      const contents = await crawlDocumentation(link);
      results.push(...contents);
    }
    s.message(chalk3.cyan(`Crawled ${results.length} content sections. Fetching existing data`));
    const newContents = await compareWithExistingData(results, index, s);
    if (newContents.length > 0) {
      s.message(chalk3.cyan(`Found ${newContents.length} new records. Upserting to Upstash`));
      await upsertToUpstash(newContents, index);
      s.stop(chalk3.green(`\u2705 Successfully crawled and upserted ${newContents.length} new records!`));
      outro(chalk3.green(`\u{1F389} Check your index at ${chalk3.cyan("https://console.upstash.com/search")}`));
    } else {
      outro(chalk3.cyan("No new contents found. Skipping upsert."));
    }
  } catch (error) {
    outro(chalk3.red("\u274C Error:") + " " + chalk3.red(error));
    outro(chalk3.red("Operation failed. Please check your credentials and try again."));
  }
}
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
export {
  crawlAndIndex
};
